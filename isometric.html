<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Isometric Blocks</title>
		<link rel="stylesheet" href="css/futuris.css" />
		<style>
			:root {
				--iso-tile: clamp(48px, 5.8vw, 80px);
				--iso-unit: 4px;
				--iso-floor: rgba(9, 14, 24, 0.85);
				--iso-floor-glow: rgba(0, 196, 255, 0.2);
				--iso-box-top: #f6f7ff;
				--iso-box-left: #9aa6d6;
				--iso-box-right: #6d79b2;
			}
			#iso-layout {
				display: grid;
				grid-template-columns: minmax(0, 1.2fr) minmax(240px, 0.8fr);
				gap: 28px;
				align-items: start;
			}
			#iso-shell {
				position: relative;
				padding: 24px 18px 24px;
				border: 1px solid rgba(0, 196, 255, 0.35);
				background: linear-gradient(160deg, rgba(4, 8, 16, 0.85), rgba(16, 10, 26, 0.85));
				box-shadow: 0 0 24px rgba(0, 196, 255, 0.2);
				min-height: 700px;
				display: grid;
				grid-template-rows: auto auto;
				gap: 12px;
			}
			#iso-stage {
				position: relative;
				min-height: 200px;
			}
			#iso-board {
				margin: 0;
				position: absolute;
				left: 50%;
				bottom: 0;
				transform: translateX(-50%);
				z-index: 1;
			}
			#iso-board svg {
				display: block;
			}
			#iso-legend {
				display: grid;
				gap: 12px;
				padding: 14px;
				border: 1px solid rgba(0, 196, 255, 0.35);
				background: linear-gradient(150deg, rgba(8, 12, 22, 0.85), rgba(18, 9, 28, 0.85));
			}
			#iso-legend h3 {
				margin: 0;
				font-size: 0.85rem;
				letter-spacing: 0.08em;
				text-transform: uppercase;
				color: #7ee6ff;
				text-shadow: 0 0 6px rgba(0, 196, 255, 0.6);
			}
			#iso-legend ul {
				margin: 0;
				padding-left: 18px;
			}
			#iso-legend li {
				margin: 6px 0;
			}
			#iso-stats {
				display: grid;
				gap: 8px;
				font-variant-numeric: tabular-nums;
			}
			#iso-stats h3 {
				margin: 8px 0 0;
				font-size: 0.85rem;
				letter-spacing: 0.08em;
				text-transform: uppercase;
				color: #7ee6ff;
				text-shadow: 0 0 6px rgba(0, 196, 255, 0.6);
			}
			#iso-stats span {
				color: #e9f6ff;
				text-shadow: 0 0 6px rgba(0, 196, 255, 0.5);
			}
			@media (max-width: 900px) {
				#iso-layout {
					grid-template-columns: 1fr;
				}
			}
		</style>
	</head>
	<body>
		<header>
			<nav id="site-nav" aria-label="Pages"></nav>
			<h1>Isometric Blocks</h1>
			<p>
				16x16 field board rendered in isometric view. Each field stores a 16-character
				string with dots for empty slots and block characters for terrain.
			</p>
		</header>
		<div id="layout">
			<main>
				<div id="iso-layout">
					<section id="iso-shell">
						<h2>Board</h2>
						<div id="iso-stage">
							<div id="iso-board" aria-label="Isometric block board"></div>
						</div>
					</section>
					<aside id="iso-legend">
						<h2>Legend</h2>
						<ul>
							<li><strong>.</strong> empty slot</li>
							<li><strong>X</strong> field-filling box (very rare)</li>
						</ul>
						<h3>Keys</h3>
						<ul>
							<li><strong>e</strong> move up-left</li>
							<li><strong>d</strong> move up-right</li>
							<li><strong>w</strong> move down-left</li>
							<li><strong>s</strong> move down-right</li>
							<li><strong>+</strong> add block</li>
							<li><strong>-</strong> remove block</li>
						</ul>
						<div id="iso-stats"></div>
					</aside>
				</div>
			</main>
		</div>

		<script src="js/vfs.js"></script>
		<script src="js/futuris.js"></script>
		<script>
			const BOARD_SIZE = 16;
			const BLOCKS_PER_FIELD = 8;
			const EMPTY_SLOT = ".";
			const isoBoardEl = document.getElementById("iso-board");
			const isoStatsEl = document.getElementById("iso-stats");
			const player = {
				row: Math.floor(Math.random() * BOARD_SIZE),
				col: Math.floor(Math.random() * BOARD_SIZE)
			};

			// Board storage design:
			// - 256-element array, index 0..255, row-major order.
			// - Each field is an 8-character string.
			// - '.' means empty, 'X' is a full box.
			const board = Array(BOARD_SIZE * BOARD_SIZE).fill(EMPTY_SLOT.repeat(BLOCKS_PER_FIELD));

			function makeFieldString(hasTower) {
				if (!hasTower) {
					return EMPTY_SLOT.repeat(BLOCKS_PER_FIELD);
				}
				const slots = Array(BLOCKS_PER_FIELD).fill(EMPTY_SLOT);
				let placed = 0;
				for (let i = 0; i < BLOCKS_PER_FIELD; i++) {
					if (Math.random() < 0.01) {
						slots[i] = "X";
						placed++;
					}
				}
				if (placed === 0) {
					slots[Math.floor(Math.random() * BLOCKS_PER_FIELD)] = "X";
				}
				return slots.join("");
			}

			function seedBoard() {
				for (let i = 0; i < board.length; i++) {
					board[i] = makeFieldString(false);
				}
			}

			function serializeBoard() {
				return {
					size: BOARD_SIZE,
					levels: BLOCKS_PER_FIELD,
					board: board.slice(),
					player: { row: player.row, col: player.col }
				};
			}

			async function saveBoard() {
				try {
					const vfs = await window.vfsReady;
					const payload = JSON.stringify(serializeBoard(), null, 2);
					await vfs.put("/isometric.json", payload);
				} catch (error) {
					console.warn("VFS save failed", error);
				}
			}

			function isValidField(value) {
				if (typeof value !== "string") return false;
				if (value.length !== BLOCKS_PER_FIELD) return false;
				for (const char of value) {
					if (char !== "X" && char !== EMPTY_SLOT) return false;
				}
				return true;
			}

			async function loadBoard() {
				try {
					const vfs = await window.vfsReady;
					const stored = await vfs.getasync("/isometric.json");
					const parsed = JSON.parse(stored);
					if (!parsed || !Array.isArray(parsed.board)) return;
					if (parsed.board.length !== BOARD_SIZE * BOARD_SIZE) return;
					for (let i = 0; i < board.length; i++) {
						const value = parsed.board[i];
						board[i] = isValidField(value) ? value : makeFieldString(false);
					}
					if (parsed.player && Number.isInteger(parsed.player.row) && Number.isInteger(parsed.player.col)) {
						const nextRow = Math.max(0, Math.min(BOARD_SIZE - 1, parsed.player.row));
						const nextCol = Math.max(0, Math.min(BOARD_SIZE - 1, parsed.player.col));
						player.row = nextRow;
						player.col = nextCol;
					}
				} catch (error) {
					// No stored state or invalid data; keep default blank board.
				}
			}

			function classifyField(field) {
				if (field.includes("X")) return "box";
				return "empty";
			}

			function renderBoard() {
				isoBoardEl.innerHTML = "";
				let countBox = 0;
				let countEmpty = 0;
				let totalBlocks = 0;

				const root = document.documentElement;
				const stageEl = document.getElementById("iso-stage");
				const desiredTile = parseFloat(getComputedStyle(root).getPropertyValue("--iso-tile")) || 64;
				const availableWidth = stageEl.clientWidth || 0;
				const maxTile = availableWidth ? Math.floor(availableWidth / BOARD_SIZE) : desiredTile;
				const tileSize = Math.max(28, Math.min(desiredTile, maxTile));
				const tileHalf = tileSize / 2;
				const tileQuarter = tileSize / 4;
				const heightUnit = parseFloat(getComputedStyle(root).getPropertyValue("--iso-unit")) || 4;
				const blockHeight = heightUnit * 8;
				const boardWidth = tileSize * BOARD_SIZE;
				const boardHeight = tileHalf * BOARD_SIZE;
				const stageHeight = boardHeight + blockHeight * BLOCKS_PER_FIELD + 32;
				const originX = (BOARD_SIZE - 1) * tileHalf;
				const originY = blockHeight * BLOCKS_PER_FIELD + 16;

				stageEl.style.height = `${stageHeight}px`;
				isoBoardEl.style.width = `${boardWidth}px`;
				isoBoardEl.style.height = `${stageHeight}px`;

				const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
				svg.setAttribute("width", `${boardWidth}`);
				svg.setAttribute("height", `${stageHeight}`);
				svg.setAttribute("viewBox", `0 0 ${boardWidth} ${stageHeight}`);
				svg.setAttribute("aria-hidden", "true");
				isoBoardEl.appendChild(svg);

				const baseFill = "rgba(16, 28, 42, 0.95)";
				const baseStroke = "rgba(0, 196, 255, 0.35)";
				const topFill = "var(--iso-box-top)";
				const leftFill = "var(--iso-box-left)";
				const rightFill = "var(--iso-box-right)";
				const playerTop = "#ff4b4b";
				const playerLeft = "#b61c2a";
				const playerRight = "#8a0f1b";

				function drawBlock(x, y, level, fills) {
					const topY = y - blockHeight * (level + 1);
					const leftPoints = [
						`${x},${topY + tileQuarter}`,
						`${x + tileHalf},${topY + tileHalf}`,
						`${x + tileHalf},${topY + tileHalf + blockHeight}`,
						`${x},${topY + tileQuarter + blockHeight}`
					].join(" ");
					const rightPoints = [
						`${x + tileSize},${topY + tileQuarter}`,
						`${x + tileHalf},${topY + tileHalf}`,
						`${x + tileHalf},${topY + tileHalf + blockHeight}`,
						`${x + tileSize},${topY + tileQuarter + blockHeight}`
					].join(" ");
					const topPoints = [
						`${x + tileHalf},${topY}`,
						`${x + tileSize},${topY + tileQuarter}`,
						`${x + tileHalf},${topY + tileHalf}`,
						`${x},${topY + tileQuarter}`
					].join(" ");

					const left = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
					left.setAttribute("points", leftPoints);
					left.setAttribute("fill", fills.left);
					svg.appendChild(left);

					const right = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
					right.setAttribute("points", rightPoints);
					right.setAttribute("fill", fills.right);
					svg.appendChild(right);

					const top = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
					top.setAttribute("points", topPoints);
					top.setAttribute("fill", fills.top);
					svg.appendChild(top);
				}

				for (let row = 0; row < BOARD_SIZE; row++) {
					for (let col = 0; col < BOARD_SIZE; col++) {
						const index = row * BOARD_SIZE + col;
						const field = board[index];
						const x = (col - row) * tileHalf + originX;
						const y = (col + row) * tileQuarter + originY;

						const basePoints = [
							`${x + tileHalf},${y}`,
							`${x + tileSize},${y + tileQuarter}`,
							`${x + tileHalf},${y + tileHalf}`,
							`${x},${y + tileQuarter}`
						].join(" ");
						const base = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
						base.setAttribute("points", basePoints);
						base.setAttribute("fill", baseFill);
						base.setAttribute("stroke", baseStroke);
						base.setAttribute("stroke-width", "1");
						svg.appendChild(base);

						let hasAny = false;
						for (let level = 0; level < BLOCKS_PER_FIELD; level++) {
							if (field[level] !== "X") continue;
							hasAny = true;
							drawBlock(x, y, level, { top: topFill, left: leftFill, right: rightFill });

							totalBlocks++;
						}
						if (player.row === row && player.col === col) {
							let highest = -1;
							for (let level = 0; level < BLOCKS_PER_FIELD; level++) {
								if (field[level] === "X") highest = level;
							}
							const playerLevel = highest + 1;
							drawBlock(x, y, playerLevel, {
								top: playerTop,
								left: playerLeft,
								right: playerRight
							});
						}
						if (hasAny) countBox++;
						else countEmpty++;
					}
				}

				isoStatsEl.innerHTML = `
					<h3>Board Stats</h3>
					<span>Empty fields: ${countEmpty}</span>
					<span>Box fields: ${countBox}</span>
					<span>Total blocks: ${totalBlocks}</span>
				`;
			}

			function movePlayer(deltaRow, deltaCol) {
				const nextRow = player.row + deltaRow;
				const nextCol = player.col + deltaCol;
				if (nextRow < 0 || nextRow >= BOARD_SIZE || nextCol < 0 || nextCol >= BOARD_SIZE) {
					return;
				}
				player.row = nextRow;
				player.col = nextCol;
				saveBoard();
				renderBoard();
			}

			document.addEventListener("keydown", (event) => {
				const key = event.key.toLowerCase();
				if (key === "e") {
					event.preventDefault();
					movePlayer(-1, 0);
				} else if (key === "d") {
					event.preventDefault();
					movePlayer(0, 1);
				} else if (key === "w") {
					event.preventDefault();
					movePlayer(0, -1);
				} else if (key === "s") {
					event.preventDefault();
					movePlayer(1, 0);
				} else if (key === "+") {
					event.preventDefault();
					const index = player.row * BOARD_SIZE + player.col;
					const field = board[index].split("");
					for (let level = 0; level < BLOCKS_PER_FIELD; level++) {
						if (field[level] !== "X") {
							field[level] = "X";
							break;
						}
					}
					board[index] = field.join("");
					saveBoard();
					renderBoard();
				} else if (key === "-") {
					event.preventDefault();
					const index = player.row * BOARD_SIZE + player.col;
					const field = board[index].split("");
					for (let level = BLOCKS_PER_FIELD - 1; level >= 0; level--) {
						if (field[level] === "X") {
							field[level] = EMPTY_SLOT;
							break;
						}
					}
					board[index] = field.join("");
					saveBoard();
					renderBoard();
				}
			});

			(async function init() {
				seedBoard();
				await loadBoard();
				renderBoard();
			})();
		</script>
	</body>
</html>
