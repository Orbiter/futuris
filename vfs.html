<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Futuris Finder</title>
		<link rel="stylesheet" href="css/futuris.css" />
		<style>
			.finder-editor {
				position: fixed;
				inset: 0;
				background: rgba(6, 8, 14, 0.72);
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 40;
			}

			.finder-editor[data-open="true"] {
				display: flex;
			}

			.vfs-editor__dialog {
				width: min(1200px, 98vw);
				max-height: 95vh;
				background: rgba(14, 18, 30, 0.98);
				border: 1px solid var(--color-border);
				border-radius: 12px;
				box-shadow: 0 18px 36px rgba(0, 0, 0, 0.45);
				padding: 16px;
				display: flex;
				flex-direction: column;
				gap: 12px;
			}

			.vfs-editor__header {
				display: flex;
				justify-content: space-between;
				align-items: baseline;
				gap: 12px;
			}

			.vfs-editor__title {
				margin: 0;
				font-size: 1rem;
				letter-spacing: 0.04em;
				text-transform: uppercase;
			}

			.vfs-editor__path {
				margin: 0;
				font-family: var(--font-mono);
				font-size: 0.8rem;
				color: rgba(230, 240, 255, 0.65);
			}

			.vfs-editor__input {
				min-height: 72vh;
				resize: vertical;
				background: rgba(10, 12, 20, 0.85);
				border: 1px solid rgba(255, 255, 255, 0.1);
				border-radius: 8px;
				color: var(--color-foreground);
				padding: 12px;
				font-family: var(--font-mono);
				font-size: 0.9rem;
			}

			.vfs-editor__input:focus {
				outline: 1px solid var(--color-primary);
			}

			.vfs-editor__actions {
				display: flex;
				justify-content: flex-end;
				gap: 8px;
			}

			.vfs-editor__actions button {
				padding: 6px 14px;
				font-size: 0.85rem;
				background: rgba(15, 20, 34, 0.9);
				border: 1px solid var(--color-border);
				color: var(--color-foreground);
				border-radius: 6px;
			}

			.vfs-editor__actions button:hover {
				border-color: var(--color-primary);
			}
		</style>
	</head>
	<body>
		<header>
			<nav id="site-nav" aria-label="Pages"></nav>
			<h1>Virtual File System</h1>
			<p>
				A Finder-style browser powered by the Futuris virtual file system.
			</p>
			<section aria-label="Status modules">
				<article>
					<span aria-hidden="true">
						<img src="icons/application-system-file-manager.svg" alt="" />
					</span>
					<div>
						<p>Volume</p>
						<p><strong>Root mount</strong></p>
						<p>IndexedDB</p>
					</div>
				</article>
				<article>
					<span aria-hidden="true">
						<img src="icons/status-folder-open.svg" alt="" />
					</span>
					<div>
						<p>Nodes</p>
						<p><strong>Tree view</strong></p>
						<p>Recursive list</p>
					</div>
				</article>
				<article>
					<span aria-hidden="true">
						<img src="icons/action-document-open-recent.svg" alt="" />
					</span>
					<div>
						<p>Files</p>
						<p><strong>Quick actions</strong></p>
						<p>Upload, download</p>
					</div>
				</article>
			</section>
		</header>

		<div id="layout">
			<main>
				<section>
					<h2>
						<img src="icons/application-system-file-manager.svg" alt="" />
						Root Browser
					</h2>
					<div id="finder-window" aria-label="File system browser">
						<div id="finder-titlebar">
							<div id="finder-controls" aria-hidden="true">
								<span></span>
								<span></span>
								<span></span>
							</div>
							<div id="finder-path">/</div>
							<div id="finder-toolbar">
								<button type="button" id="finder-create-folder">New Folder</button>
								<button type="button" id="finder-upload-button">Upload File</button>
								<input type="file" id="finder-upload-input" />
							</div>
						</div>
						<div id="finder-body">
							<div>
								<ul id="finder-list" aria-label="Root contents"></ul>
								<p id="finder-empty">No files yet. Upload a file or create a folder.</p>
							</div>
							<div id="finder-preview">
								<h3 id="finder-preview-title">Preview</h3>
								<div id="finder-preview-body">
									<p>Select a .txt or .md file to preview.</p>
								</div>
							</div>
						</div>
					</div>
				</section>
			</main>
		</div>

		<div id="vfs-editor" class="finder-editor" aria-hidden="true">
			<div
				id="vfs-editor-dialog"
				class="vfs-editor__dialog"
				role="dialog"
				aria-modal="true"
				aria-labelledby="vfs-editor-title"
			>
				<div id="vfs-editor-header" class="vfs-editor__header">
					<h3 id="vfs-editor-title" class="vfs-editor__title">Edit file</h3>
					<p id="vfs-editor-path" class="vfs-editor__path"></p>
				</div>
				<textarea id="vfs-editor-input" class="vfs-editor__input" spellcheck="false"></textarea>
				<div id="vfs-editor-actions" class="vfs-editor__actions">
					<button type="button" id="vfs-editor-discard">discard</button>
					<button type="button" id="vfs-editor-save">save</button>
				</div>
			</div>
		</div>

		<script defer src="js/futuris.js"></script>
		<script defer src="js/vfs.js"></script>
		<script defer src="js/highlight.min.js"></script>
		<script>
			window.addEventListener("DOMContentLoaded", () => {
(function () {
	const finderList = document.getElementById("finder-list");
	const finderEmpty = document.getElementById("finder-empty");
	const createFolderButton = document.getElementById("finder-create-folder");
	const uploadButton = document.getElementById("finder-upload-button");
	const uploadInput = document.getElementById("finder-upload-input");
	const previewTitle = document.getElementById("finder-preview-title");
	const previewBody = document.getElementById("finder-preview-body");
	const editorOverlay = document.getElementById("vfs-editor");
	const editorTitle = document.getElementById("vfs-editor-title");
	const editorPathLabel = document.getElementById("vfs-editor-path");
	const editorInput = document.getElementById("vfs-editor-input");
	const editorDiscard = document.getElementById("vfs-editor-discard");
	const editorSave = document.getElementById("vfs-editor-save");
	const expandedPaths = new Set(["/"]);
	let selectedPath = null;
	let activeDropTarget = null;
	let editorPath = null;

	if (
		!finderList ||
		!uploadInput ||
		!uploadButton ||
		!createFolderButton ||
		!previewTitle ||
		!previewBody ||
		!editorOverlay ||
		!editorTitle ||
		!editorPathLabel ||
		!editorInput ||
		!editorDiscard ||
		!editorSave
	) {
		return;
	}

	const seedEntries = [
		{ path: "/Projects/", value: "" },
		{ path: "/Projects/brief.txt", value: "Futuris VFS sample file." },
		{ path: "/Design/", value: "" },
		{ path: "/Design/notes.md", value: "Palette notes and layout ideas." },
		{ path: "/Readme.md", value: "Welcome to the Futuris VFS root." }
	];

	const refreshDelay = (fn) => {
		setTimeout(fn, 120);
	};

	const escapeHtml = (value) =>
		String(value)
			.replace(/&/g, "&amp;")
			.replace(/</g, "&lt;")
			.replace(/>/g, "&gt;")
			.replace(/"/g, "&quot;");

	const renderHighlighted = (text, languageHint) => {
		if (window.hljs && typeof window.hljs.highlight === "function") {
			try {
				if (languageHint) {
					return window.hljs.highlight(text, { language: languageHint }).value;
				}
				return window.hljs.highlightAuto(text).value;
			} catch (error) {
				return escapeHtml(text);
			}
		}
		return escapeHtml(text);
	};

	const readFileAsText = (file) =>
		new Promise((resolve, reject) => {
			const reader = new FileReader();
			reader.onload = () => resolve(reader.result || "");
			reader.onerror = () => reject(reader.error || new Error("Upload failed"));
			reader.readAsText(file);
		});

	const buildTree = (entries) => {
		const root = { name: "/", path: "/", type: "folder", children: new Map() };

		entries.forEach((entry) => {
			if (!entry) return;
			const isDir = entry.endsWith("/");
			const parts = entry.split("/").filter(Boolean);
			let current = root;
			let currentPath = "/";

			parts.forEach((part, index) => {
				const isLast = index === parts.length - 1;
				const partIsDir = isLast ? isDir : true;
				const nextPath = `${currentPath}${part}${partIsDir ? "/" : ""}`;
				if (!current.children.has(part)) {
					current.children.set(part, {
						name: part,
						path: nextPath,
						type: partIsDir ? "folder" : "file",
						children: new Map()
					});
				}
				const child = current.children.get(part);
				if (partIsDir) {
					child.type = "folder";
				} else if (isLast) {
					child.type = "file";
				}
				current = child;
				currentPath = nextPath;
			});
		});

		return root;
	};

	const renderTree = (node, container) => {
		const nodes = Array.from(node.children.values()).sort((a, b) => {
			if (a.type !== b.type) {
				return a.type === "folder" ? -1 : 1;
			}
			return a.name.localeCompare(b.name);
		});

		nodes.forEach((child) => {
			const li = document.createElement("li");
			li.dataset.path = child.path;
			li.dataset.kind = child.type;

			const row = document.createElement("div");
			row.setAttribute("draggable", "true");
			row.dataset.dragPath = child.path;
			if (selectedPath === child.path) {
				row.dataset.selected = "true";
			}

			if (child.type === "folder") {
				const toggle = document.createElement("button");
				toggle.type = "button";
				toggle.dataset.action = "toggle";
				toggle.setAttribute("draggable", "false");
				toggle.textContent = expandedPaths.has(child.path) ? "v" : ">";
				toggle.setAttribute("aria-label", expandedPaths.has(child.path) ? "Collapse folder" : "Expand folder");
				row.appendChild(toggle);
				row.dataset.dropPath = child.path;
			} else {
				const spacer = document.createElement("span");
				spacer.setAttribute("aria-hidden", "true");
				spacer.dataset.role = "toggle-spacer";
				row.appendChild(spacer);
			}

			const icon = document.createElement("img");
			icon.alt = "";
			icon.setAttribute("draggable", "false");
			icon.dataset.icon = child.type;
			icon.src = child.type === "folder" ? "icons/place-folder.svg" : "icons/mime-text-x-generic.svg";
			row.appendChild(icon);

			const name = document.createElement("span");
			name.textContent = child.name;
			name.dataset.role = "name";
			row.appendChild(name);

			const actions = document.createElement("span");
			actions.dataset.role = "actions";

			if (child.type === "file") {
				const edit = document.createElement("button");
				edit.type = "button";
				edit.dataset.action = "edit";
				edit.setAttribute("draggable", "false");
				edit.title = "Edit file";
				const editIcon = document.createElement("img");
				editIcon.alt = "";
				editIcon.setAttribute("draggable", "false");
				editIcon.dataset.icon = "edit";
				editIcon.src = "icons/action-document-open.svg";
				edit.appendChild(editIcon);
				actions.appendChild(edit);

				const download = document.createElement("button");
				download.type = "button";
				download.dataset.action = "download";
				download.setAttribute("draggable", "false");
				download.title = "Download file";
				const downloadIcon = document.createElement("img");
				downloadIcon.alt = "";
				downloadIcon.setAttribute("draggable", "false");
				downloadIcon.dataset.icon = "download";
				downloadIcon.src = "icons/action-document-save-as.svg";
				download.appendChild(downloadIcon);
				actions.appendChild(download);
			}

			const remove = document.createElement("button");
			remove.type = "button";
			remove.dataset.action = "delete";
			remove.setAttribute("draggable", "false");
			remove.title = "Delete";
			const deleteIcon = document.createElement("img");
			deleteIcon.alt = "";
			deleteIcon.setAttribute("draggable", "false");
			deleteIcon.dataset.icon = "delete";
			deleteIcon.src = "icons/action-edit-delete.svg";
			remove.appendChild(deleteIcon);
			actions.appendChild(remove);

			row.appendChild(actions);
			li.appendChild(row);

			if (child.type === "folder" && expandedPaths.has(child.path)) {
				const nestedList = document.createElement("ul");
				nestedList.dataset.dropPath = child.path;
				renderTree(child, nestedList);
				li.appendChild(nestedList);
			}

			container.appendChild(li);
		});
	};

	const refreshView = async () => {
		const vfs = await window.vfsReady;
		const entries = await vfs.ls("/");
		if (entries.length === 0) {
			for (const entry of seedEntries) {
				await vfs.put(entry.path, entry.value);
			}
		}

		const updatedEntries = await vfs.ls("/");
		finderList.innerHTML = "";
		const tree = buildTree(updatedEntries);

		const rootItem = document.createElement("li");
		rootItem.dataset.path = "/";
		rootItem.dataset.kind = "folder";
		const rootRow = document.createElement("div");
		rootRow.dataset.dropPath = "/";
		rootRow.dataset.root = "true";

		const rootToggle = document.createElement("button");
		rootToggle.type = "button";
		rootToggle.dataset.action = "toggle";
		rootToggle.setAttribute("draggable", "false");
		rootToggle.textContent = expandedPaths.has("/") ? "v" : ">";
		rootToggle.setAttribute("aria-label", expandedPaths.has("/") ? "Collapse folder" : "Expand folder");
		rootRow.appendChild(rootToggle);

		const rootIcon = document.createElement("img");
		rootIcon.alt = "";
		rootIcon.setAttribute("draggable", "false");
		rootIcon.dataset.icon = "folder";
		rootIcon.src = "icons/place-folder.svg";
		rootRow.appendChild(rootIcon);

		const rootName = document.createElement("span");
		rootName.textContent = "/";
		rootName.dataset.role = "name";
		rootRow.appendChild(rootName);

		rootItem.appendChild(rootRow);

		if (expandedPaths.has("/")) {
			const nestedList = document.createElement("ul");
			nestedList.dataset.dropPath = "/";
			renderTree(tree, nestedList);
			rootItem.appendChild(nestedList);
		}

		finderList.appendChild(rootItem);
		finderEmpty.style.display = updatedEntries.length ? "none" : "block";
	};

	const refreshSoon = () => {
		refreshDelay(refreshView);
	};

	const showPreviewPlaceholder = (message) => {
		previewTitle.textContent = "Preview";
		previewBody.innerHTML = `<p>${escapeHtml(message)}</p>`;
	};

	const openEditor = async (path) => {
		if (!path || path.endsWith("/")) return;
		try {
			const vfs = await window.vfsReady;
			const contents = await vfs.getasync(path);
			editorPath = path;
			editorTitle.textContent = "Edit file";
			editorPathLabel.textContent = path;
			editorInput.value = contents;
			editorOverlay.dataset.open = "true";
			editorOverlay.setAttribute("aria-hidden", "false");
			editorInput.focus();
		} catch (error) {
			window.alert("Unable to load file for editing.");
		}
	};

	const closeEditor = () => {
		editorPath = null;
		editorOverlay.removeAttribute("data-open");
		editorOverlay.setAttribute("aria-hidden", "true");
		editorInput.value = "";
	};

	const extensionToLanguage = (name) => {
		const match = name.toLowerCase().match(/\.([a-z0-9]+)$/);
		if (!match) return null;
		const ext = match[1];
		const map = {
			js: "javascript",
			mjs: "javascript",
			cjs: "javascript",
			ts: "typescript",
			jsx: "javascript",
			tsx: "typescript",
			json: "json",
			md: "markdown",
			txt: "plaintext",
			html: "xml",
			htm: "xml",
			css: "css",
			yml: "yaml",
			yaml: "yaml",
			sh: "bash",
			bash: "bash",
			py: "python",
			rs: "rust",
			go: "go",
			java: "java",
			c: "c",
			h: "c",
			cpp: "cpp",
			hpp: "cpp"
		};
		return map[ext] || null;
	};

	const updatePreview = async (path) => {
		if (!path) {
			showPreviewPlaceholder("Select a file to preview.");
			return;
		}

		const fileName = path.split("/").pop() || "";
		const languageHint = extensionToLanguage(fileName);

		try {
			const vfs = await window.vfsReady;
			const contents = await vfs.getasync(path);
			previewTitle.textContent = fileName;
			const highlighted = renderHighlighted(contents, languageHint);
			const languageClass = languageHint ? ` language-${languageHint}` : "";
			previewBody.innerHTML = `<pre><code class="hljs${languageClass}">${highlighted}</code></pre>`;
		} catch (error) {
			showPreviewPlaceholder("Unable to load file preview.");
		}
	};

	createFolderButton.addEventListener("click", async () => {
		const name = window.prompt("Folder name");
		if (!name) return;
		const trimmed = name.trim().replace(/^\/+|\/+$/g, "");
		if (!trimmed || trimmed.includes("/")) {
			window.alert("Folder name must be a single segment.");
			return;
		}
		const vfs = await window.vfsReady;
		await vfs.mkdir(`/${trimmed}/`);
		expandedPaths.add(`/${trimmed}/`);
		refreshSoon();
	});

	uploadButton.addEventListener("click", () => {
		uploadInput.click();
	});

	uploadInput.addEventListener("change", async (event) => {
		const files = Array.from(event.target.files || []);
		if (!files.length) return;
		const vfs = await window.vfsReady;
		for (const file of files) {
			const contents = await readFileAsText(file);
			await vfs.put(`/${file.name}`, contents);
		}
		uploadInput.value = "";
		refreshSoon();
	});

	finderList.addEventListener("click", async (event) => {
		const button = event.target.closest("button[data-action]");
		if (!button) return;
		const item = button.closest("li");
		if (!item) return;
		const path = item.dataset.path;
		const action = button.dataset.action;
		const vfs = await window.vfsReady;

		if (action === "toggle") {
			if (expandedPaths.has(path)) {
				expandedPaths.delete(path);
			} else {
				expandedPaths.add(path);
			}
			refreshView();
			return;
		}

		if (action === "delete") {
			await vfs.deleteTree(path);
			if (path.endsWith("/")) {
				expandedPaths.delete(path);
				if (selectedPath && selectedPath.startsWith(path)) {
					selectedPath = null;
					showPreviewPlaceholder("Select a file to preview.");
				}
			} else if (selectedPath === path) {
				selectedPath = null;
				showPreviewPlaceholder("Select a file to preview.");
			}
			refreshSoon();
			return;
		}

		if (action === "download") {
			try {
				const contents = await vfs.getasync(path);
				const blob = new Blob([contents], { type: "text/plain" });
				const url = URL.createObjectURL(blob);
				const link = document.createElement("a");
				link.href = url;
				link.download = path.split("/").pop() || "download.txt";
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				URL.revokeObjectURL(url);
			} catch (error) {
				window.alert("Unable to download file.");
			}
			return;
		}

		if (action === "edit") {
			openEditor(path);
		}
	});

	finderList.addEventListener("click", (event) => {
		const button = event.target.closest("button[data-action]");
		if (button) return;
		const row = event.target.closest("li > div");
		if (!row) return;
		const item = row.closest("li");
		if (!item || item.dataset.kind !== "file") return;
		selectedPath = item.dataset.path;
		refreshView();
		updatePreview(selectedPath);
	});

	finderList.addEventListener("dragstart", (event) => {
		const row = event.target.closest("[data-drag-path]");
		if (!row) return;
		if (event.target.closest("[data-role=\"actions\"], button, img, [data-action=\"toggle\"]")) {
			event.preventDefault();
			return;
		}
		event.dataTransfer.setData("text/plain", row.dataset.dragPath);
		event.dataTransfer.effectAllowed = "move";
		row.dataset.dragging = "true";
	});

	finderList.addEventListener("dragend", (event) => {
		const row = event.target.closest("[data-drag-path]");
		if (row) {
			delete row.dataset.dragging;
		}
		if (activeDropTarget) {
			delete activeDropTarget.dataset.dropTarget;
			activeDropTarget = null;
		}
	});

	finderList.addEventListener("dragover", (event) => {
		const target = event.target.closest("[data-drop-path]");
		if (!target) return;
		event.preventDefault();
		event.dataTransfer.dropEffect = "move";
		if (activeDropTarget && activeDropTarget !== target) {
			delete activeDropTarget.dataset.dropTarget;
		}
		activeDropTarget = target;
		activeDropTarget.dataset.dropTarget = "true";
	});

	finderList.addEventListener("dragleave", (event) => {
		const target = event.target.closest("[data-drop-path]");
		if (!target || !activeDropTarget) return;
		if (target === activeDropTarget) {
			delete activeDropTarget.dataset.dropTarget;
			activeDropTarget = null;
		}
	});

	finderList.addEventListener("drop", async (event) => {
		const target = event.target.closest("[data-drop-path]");
		if (!target) return;
		event.preventDefault();
		const srcPath = event.dataTransfer.getData("text/plain");
		const destDir = target.dataset.dropPath || "/";
		if (!srcPath || !destDir) return;
		const vfs = await window.vfsReady;
		try {
			const destPath = await vfs.moveTree(srcPath, destDir);
			if (expandedPaths.has(srcPath)) {
				expandedPaths.delete(srcPath);
				expandedPaths.add(destPath);
			}
			if (selectedPath === srcPath) {
				selectedPath = destPath;
			}
		} catch (error) {
			if (error instanceof Error && error.message) {
				window.alert(error.message);
			} else {
				window.alert("Unable to move entry.");
			}
		}
		if (activeDropTarget) {
			delete activeDropTarget.dataset.dropTarget;
			activeDropTarget = null;
		}
		refreshSoon();
	});

	editorOverlay.addEventListener("click", (event) => {
		if (event.target === editorOverlay) {
			closeEditor();
		}
	});

	editorDiscard.addEventListener("click", () => {
		closeEditor();
	});

	editorSave.addEventListener("click", async () => {
		if (!editorPath) {
			closeEditor();
			return;
		}
		const vfs = await window.vfsReady;
		await vfs.put(editorPath, editorInput.value);
		const savedPath = editorPath;
		closeEditor();
		if (selectedPath === savedPath) {
			updatePreview(savedPath);
		}
	});

	const clearActiveDrop = () => {
		if (activeDropTarget) {
			delete activeDropTarget.dataset.dropTarget;
			activeDropTarget = null;
		}
	};

	refreshView();
	updatePreview(selectedPath);
})();
			});
		</script>
	</body>
</html>
